#!/usr/bin/env bash
# vpm v2.0 - Network Enabled
# Setup: Change REPO_URL to your actual server

# Where does Vanadium look for updates?
REPO_URL="https://gold-is-eepy-now.github.io/vanadium-repo"

DB_DIR="/var/lib/vpm/installed"
CACHE_DIR="/var/cache/vpm"
INDEX_FILE="$CACHE_DIR/index.txt"
mkdir -p "$DB_DIR" "$CACHE_DIR"

error() { echo -e "\e[31m[ERROR]\e[0m $1"; exit 1; }
msg()   { echo -e "\e[32m[VPM]\e[0m $1"; }

# --- Helper: Compare Versions ---
# Returns 0 if $1 == $2, 1 if $1 < $2 (upgrade needed), 2 if $1 > $2
ver_check() {
    [[ "$1" == "$2" ]] && return 0
    local winner=$(echo -e "$1\n$2" | sort -V | tail -n1)
    [[ "$winner" == "$2" ]] && return 1 # Update available
    return 2
}

cmd_update() {
    msg "Fetching package list from $REPO_URL..."
    if curl -sfL "$REPO_URL/index.txt" -o "$INDEX_FILE"; then
        msg "Database updated."
    else
        error "Could not reach repository."
    fi
}

cmd_upgrade() {
    [[ -f "$INDEX_FILE" ]] || cmd_update
    msg "Checking for updates..."
    
    # Loop through installed packages
    for pkg_path in "$DB_DIR"/*; do
        [ -e "$pkg_path" ] || continue
        NAME=$(basename "$pkg_path")
        
        # Get installed version from the DB file metadata (hacky but works)
        # We assume you save VERSION inside the DB file header or name
        # For V2, let's rely on the index.
        
        # Real logic: Read current version from stored PKG_INFO
        if [ -f "/var/lib/vpm/pkginfo/$NAME" ]; then
             source "/var/lib/vpm/pkginfo/$NAME"
             CURRENT_VER="$VERSION"
        else
             CURRENT_VER="0.0"
        fi

        # Find remote version in index
        # Index format: name version url
        REMOTE_DATA=$(grep "^$NAME " "$INDEX_FILE")
        
        if [[ -n "$REMOTE_DATA" ]]; then
            REMOTE_VER=$(echo "$REMOTE_DATA" | awk '{print $2}')
            URL=$(echo "$REMOTE_DATA" | awk '{print $3}')
            
            ver_check "$CURRENT_VER" "$REMOTE_VER"
            if [[ $? -eq 1 ]]; then
                echo "UPDATE FOUND: $NAME ($CURRENT_VER -> $REMOTE_VER)"
                cmd_install "$URL"
            fi
        fi
    done
}

cmd_install() {
    INPUT="$1"
    
    # Is it a URL?
    if [[ "$INPUT" == http* ]]; then
        FILENAME=$(basename "$INPUT")
        msg "Downloading $FILENAME..."
        curl -L "$INPUT" -o "$CACHE_DIR/$FILENAME"
        PKG="$CACHE_DIR/$FILENAME"
    # Is it a package name in the index?
    elif grep -q "^$INPUT " "$INDEX_FILE" 2>/dev/null; then
        URL=$(grep "^$INPUT " "$INDEX_FILE" | awk '{print $3}')
        cmd_install "$URL"
        return
    else
        PKG="$INPUT"
    fi

    [[ -f "$PKG" ]] || error "Package '$PKG' not found."

    # Extract info
    TMP=$(mktemp -d)
    tar -xf "$PKG" -C "$TMP" ./PKG_INFO 2>/dev/null || error "No PKG_INFO found"
    source "$TMP/PKG_INFO"
    
    msg "Installing $NAME ($VERSION)..."
    
    # Save metadata for future upgrades
    mkdir -p "/var/lib/vpm/pkginfo"
    cp "$TMP/PKG_INFO" "/var/lib/vpm/pkginfo/$NAME"

    # Install files
    tar -xvf "$PKG" -C / --exclude='./PKG_INFO' > "$CACHE_DIR/files.tmp"
    
    # Update DB
    cat "$CACHE_DIR/files.tmp" | while read -r file; do
        if [[ "$file" != "/" ]]; then echo "/$file" >> "$DB_DIR/$NAME"; fi
    done
    rm -rf "$TMP" "$CACHE_DIR/files.tmp"
    msg "Installed successfully."
}

# ... (Include cmd_create, cmd_remove, cmd_list from V1 here) ...

case "$1" in
    update)  cmd_update ;;
    upgrade) cmd_upgrade ;;
    install) cmd_install "$2" ;;
    create)  # (Use V1 logic, but ensure PKG_INFO has VERSION=x.x) 
             ;;
    *)       echo "Usage: vpm {update|upgrade|install|remove|create}" ;;
esac
